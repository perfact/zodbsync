#!/usr/bin/env python
#
# perfact-zopeplayback  -  Upload a subpath into the Data.fs
#

import sys
# for argument parsing and executing git commands
import argparse
import os
import subprocess

# for Data.fs reading / writing:
import perfact.zodbsync

# advanced logging is only available if python-perfact is available
try:
    import perfact.loggingtools
except ImportError:
    pass

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Upload objects to the Data.fs'
    )
    default_configfile = '/etc/perfact/modsync/zodb.py'
    parser.add_argument('--config', '-c',
                        type=str,
                        help=('Path to config (default: %s)' %
                              default_configfile),
                        default=default_configfile)
    parser.add_argument(
        '--override', '-o', action='store_true',
        help='Override object type changes when uploading',
        default=False)
    parser.add_argument(
            '--no-recurse', action='store_true',
            help="Only upload metadata, do not remove elements or recurse."
            " Note: If a path no longer present on the file system is given, "
            " it is still removed.",
            default=False)
    parser.add_argument(
            '--skip-errors', action='store_true',
            help="Skip failed objects and continue",
            default=False)
    group = parser.add_mutually_exclusive_group()
    group.add_argument(
        '--pick', action='store_true',
        help='''
        Switch to cherry-pick mode. The positional arguments are then
        interpreted as commits, which are checked for compatibility and
        applied, playing back all affected paths at the end.
        ''',
    )
    group.add_argument(
        '--apply', action='store_true',
        help='''
        Switch to apply mode. The positional arguments are then interpreted as
        patch files which are applied to the repository (using git am). If
        successful, the changed objects are played back. Else, the am session
        is automatically rolled back.
        ''',
    )

    parser.add_argument(
        'path', nargs='+', type=str,
        help='''
        In default mode, paths of Data.FS objects to be played back. With
        --pick, commits to be applied. With --apply, patch files to be applied.
        The object list is then determined automatically.
        ''',
        )
    if 'perfact.loggingtools' in sys.modules:
        perfact.loggingtools.addArgs(parser, name='ZODBSync')

    args = parser.parse_args()

    logger = None
    if 'perfact.loggingtools' in sys.modules:
        logger = perfact.loggingtools.createLogger(args=args, name='ZODBSync')
    paths = args.path
    override = args.override
    recurse = not args.no_recurse

    pickmode = args.pick
    applymode = args.apply

    # Setup sync toolkit
    sync = perfact.zodbsync.ZODBSync(conffile=args.config, logger=logger)

    sync.acquire_lock()

    if pickmode or applymode:
        def gitcmd(*args):
            return ['git', '-C', sync.base_dir] + list(args)

        # Check that there are no unstaged changes
        dirty_workdir = len(subprocess.check_output(
            gitcmd('status', '--porcelain'),
        )) > 0
        if dirty_workdir:
            print("You have unstaged changes. Please commit or stash them")
            sys.exit(1)

        orig_commit = subprocess.check_output(
            gitcmd('show-ref', '--head', 'HEAD'),
            universal_newlines=True
        ).split()[0]
        print('Original commit: %s' % orig_commit)

        changed_files = set()

        # compatibility since python2 has no subprocess.DEVNULL
        fnull = open(os.devnull, 'w')

        # recurse and override are set automatically for these modes
        recurse = False
        override = True

    if applymode:
        # somehow, if we pass relative filenames to git while it is called with
        # '-C' or even with '--git-dir' and '--work-tree', they are no longer
        # interpreted relative to the current work dir. Therefore, we open the
        # files ourselves and pass them via stdin
        proc = subprocess.Popen(gitcmd('am'),
            stdin=subprocess.PIPE
        )
        for path in paths:
            print("Reading from %s" % path)
            with open(path) as f:
                proc.stdin.write(f.read())

        proc.stdin.close()
        proc.wait()
        if proc.returncode:
            print('Error applying patches. Rolling back')
            subprocess.call(gitcmd('am', '--abort'))
            sys.exit(1)

        changed_files.update(set(subprocess.check_output(
            gitcmd('diff-tree', '--no-commit-id', '--name-only', '-r',
                orig_commit, 'HEAD'),
            universal_newlines=True,
        ).strip().split('\n')))

    if pickmode:
        commits = paths
        paths = set()

        for commit in commits:
            print('Checking and applying %s.' % commit)
            # obtain files affected by the commit
            files = [
                line for line in subprocess.check_output(
                    gitcmd('diff-tree', '--no-commit-id', '--name-only', '-r',
                           commit), universal_newlines=True
                ).strip().split('\n')
                if line
            ]

            # check if these files currently differ from their state *before*
            # the given commit
            try:
                subprocess.check_call(
                    gitcmd('diff', '--exit-code', commit+'~', 'HEAD', '--',
                           *files)
                )
            except subprocess.CalledProcessError:
                print('Unable to apply %s due to the above differences.' %
                      commit)
                subprocess.check_call(gitcmd('reset', '--hard', orig_commit))
                sys.exit(1)

            changed_files.update(files)
            subprocess.check_call(
                gitcmd('cherry-pick', commit),
                stdout=fnull
            )

    if applymode or pickmode:
        paths = sorted({
            filename[len('__root__'):].rsplit('/', 1)[0]
            for filename in changed_files
        })
    else:
        paths.sort()

    note = 'perfact-zopeplayback'
    if len(paths) == 1:
        note += ': ' + paths[0]
    txn_mgr = sync.start_transaction(note=note)

    try:
        for path in paths:
            sync.playback(path=path,
                          override=override,
                          recurse=recurse,
                          skip_errors=args.skip_errors)
        sync.release_lock()
    except Exception:
        print('Error with path ' + path)
        txn_mgr.abort()
        raise
    finally:
        txn_mgr.commit()
